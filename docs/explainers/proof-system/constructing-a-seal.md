---
sidebar_position: 3
---

# Constructing a Seal

> The **seal** is the part of the [receipt](what_is_a_receipt.md) that allows third-parties to authenticate the validity of the [journal](../zkvm/zkvm_overview.md). It's the zero-knowledge proof that sits at the crux of our technology, showing that the journal was faithfully constructed (according to the program defined by the [methodID](../zkvm/zkvm_overview.md)). 

The construction of a seal is highly technical, relying on several recent advances in the world of zero-knowledge cryptography. In this series of 10 brief lessons, we walk through the construction of a RISC Zero seal with as little technical jargon as possible. 

You can peek behind the formulas on the [Google Sheet version](https://docs.google.com/spreadsheets/d/1Onr41OozD62y-B0jIL7bHAH5kf771-o4xvmnHUFpOyo/edit?usp=sharing) or [download a PDF](assets/fibonacci-stark.pdf). If you make sense of these 10 lessons, you'll have a solid handle on the mechanics of a zk-STARK (and we'd likely love to [hire you](../../../careers)).

The [proof system sequence diagram](proof-system-sequence-diagram.md) describes this process in more generality; we suggest going back and forth between this document and the sequence diagram. 

## Lesson 1: The Execution Trace
							
>When any code executes in the RISC Zero virtual machine, each step of that execution is recorded in an [`Execution Trace`](what_is_a_trace.md). 

We show a simplified example, computing 4 steps of a Fibonacci sequence modulo 97, using two user-specified inputs. 

![Lesson 1: The Execution Trace](assets/fibonacci-01.png)

In this example, our trace consists of 6 `columns`. 
- Each of the first three columns is a record of the internal state of a register at each clock cycle from initialization until termination. We call these `Data Columns`. 
- The next three columns are `Control Columns`, which we use to mark initialization and termination points. 	

> In the full RISC Zero protocol, the `Data Columns` hold the state of the RISC-V processor, including ISA registers, the program counter, and various microarchitecture details such as instruction decoding data, ALU registers, etc., while the `Control Columns` handle system initialization and shutdown, the initial program code to load into memory before execution, and other control signals that don't depend on the programs execution.	

The full implementation also has `PLONK Columns`, allowing for RISC-V memory emulation. The `PLONK Columns` are not necessary in this simplified example. 						

## Lesson 2: Rule-checks to Validate RISC-V Execution

Here, we introduce a number of rule-checking cells in order to demonstrate the validity of the RISC-V execution. In this example, we show six rules. In the full RISC-V implementation, we check over 100 rules in order to validate the execution trace. 

![Lesson 2: Rule-checks to Validate RISC-V Execution](assets/fibonacci-02.png)

Each rule check is written as the product of two terms, modulo 97. The first term equals zero when the rule holds. The second term equals zero when we don't want to enforce the rule. 									

Each rule checking column can be expressed as a multi-input, single-output polynomial, where the inputs are some combination of entries in the trace; we call these `rule-checking polynomials`.	

## Lesson 3: Padding the Trace

Before encoding each column as a polynomial, we append random padding to the end of the Execution Trace, which allows for a zero-knowledge protocol. This random noise is generated by the host system's cryptographically secure pseudorandom number generator. We set the Control columns to 0 for these random noise rows, in order to turn off our rule checks.										
![Lesson 3: Padding the Trace](assets/fibonacci-03.png)

## Lesson 4: Constructing Trace Polynomials
Let's remove the `rule-checking columns` for a minute and turn our attention toward encoding our Trace data in terms of polynomials. Throughout these lessons, all of the arithmetic takes place in $\mathbb{F}_{97}$. 

*From here on, the lessons assume some familiarity with finite fields. If finite fields are foreign to you, fear not! This [finite fields primer](../../reference-docs/about-finite-fields.md) covers just enough to make sense of RISC Zero's use of finite fields.* 

Every element of $\mathbb{F}_{97}$ can be written as a power of 5. In other words, the elements of $\mathbb{F}_{97}$ are $0, 5^0, 5^1, \ldots,$ and $5^{95}$. We write $\mathcal{D}(5^{12})$ for the set of powers of $5^{12}$ and $\mathcal{D}(5^{3})$ for the set of powers of $5^{3}$. Each of these sets is "evenly spaced" throughout $\mathbb{F}_{97}$, which facilitates the use of [number theoretic transforms](../../reference-docs/about-ntts-and-fourier.md).

>Put succinctly, running an iNTT on a `trace column` gives the coefficients of a `trace polynomial`. 

![Lesson 4a: iNTT of Trace Columns forms Trace Polynomials](assets/fibonacci-04a.png)

The table above shows the python code and associated input/output arrays; the input arrays correspond to the `trace columns` and the output arrays are the coefficients of the `trace polynomials`. The key features about the `trace polynomials` are that 
- they are at most degree 7 and 
- the `trace polynomial` evaluations on $\mathcal{D}(5^{12})$ precisely match the data in the padded execution trace. 

![Lesson 4b: Coefficients of Trace Polynomials](assets/fibonacci-04b.png)	

> Evaluating the `trace polynomial` on the larger set $\mathcal{D}(5^{3})$ gives a Reed-Solomon encoded `trace block`. 

We say the `block` is a `degree 4 expansion` of the `column`, and that the Reed-Solomon encoding has `rate` $\frac{1}{4}$. Reed-Solmon encoding improves the soundness of the protocol by amplifying any errors in an invalid trace. 


![Lesson 4c: Evaluating Trace Polynomials](assets/fibonacci-04c.png)		
## Lesson 5: ZK Commitments of the Trace Data

The next step is for the Prover to commit the `trace polynomials` into a Merkle tree. 

>In order to maintain a Zero-Knowledge protocol, the Prover evaluates each `trace polynomial` over a `shift` of $\mathcal{D}(5^3)$. 

Specifically, we evaluate each `trace polynomial` over $x=5, 5^4, 5^7, ..., 5^{93}.$ 		

![Lesson 5: ZK Commitments](assets/fibonacci-05.png)									
Note that because of the `shift`, the yellow and blue cells in `Data Columns 1, 2, and 3` no longer match the `Inputs` and `Asserted Outputs`. In fact, this shift in the evaluation domain `disguises` all the `Trace Data`. 

> We only reveal information about the `disguised trace`, and the random padding we appended is sufficient to prevent an attacker from deducing any connection between the disguised trace and the actual trace. 				

## Lesson 6: Constraint Polynomials

Now that we've encoded our `trace columns` into `trace polynomials`, let's return to our original Reed-Solomon domain and add back in our `rule-checking cells`.

![Lesson 6: Constraint Polynomials](assets/fibonacci-06.png)	
Of course, we shouldn't expect these `rule checks` to evaluate to 0 in the `redundancy rows`, as they're not directly associated with the data from the `trace`. 										

> Conveniently, by writing these `rule checks` in terms of our `trace polynomials`, we can convert our multi-input rule checking polynomials into single-input polynomials, which we call `constraint polynomials`.						

Note that each `constraint polynomial` will evaluate to 0 at the input values that are associated with actual trace data. 		

## Lesson 7: Mixing Constraint Polynomials

Here, we add one new column, which `mixes` our `constraint polynomials` into a single `mixed constraint polynomial`.

After the Prover commits a Merkle root for the `control polynomials` and the `data polynomials` (and the `PLONK polynomials` in the full implementation), those Merkle roots are used as entropy to randomly generate a `constraint mixing parameter` $\alpha_1$.	

Letting $c_i$ denote the constraint polynomials, we write:

 $C(x) = \alpha_1^0 * c_0(x) + \alpha_1^1 c_1(x) + ... + \alpha_1^5 c_5(x)$	

![Lesson 7: Mixing Constraint Polynomials](assets/fibonacci-07.png)

Note that if each $c_i$ evaluates to 0 at some input $x$, then $C$ will also evaluate to 0 for that input.					

In this example, the degree of the `mixed constraint polynomial` is equal to the degree of the `trace polynomials`, because the `rule-checking` involved is particularly simple. In more complicated examples, composing our `rule checking polynomials` with our `trace polynomials` would yield `high degree constraint polynomials.` In that case, we'd add an extra step at the end of Lesson 9 to split our `high degree validity polynomial` into a few `low degree validity polynomials`.		

## Lesson 8: The Core of the RISC Zero STARK

> The Prover constructs the `validity polynomial` by dividing the `mixed constraint polynomial` from the previous lesson by the publicly known `zeros polynomial`. 	
$V(x) = C(x) / Z(x)$

In our example, the `zeros polynomial` is 

$Z(x) = (x-1)(x-47)(x-75)(x-33)(x-96)(x-50)(x-22)(x-64)$, where the 8 terms are the elements of $\mathcal{D}(5^{12})$. 

![Lesson 8: The Core of the RISC Zero STARK](assets/fibonacci-08.png)

>Normally, when we divide two low degree polynomials, we don't expect to get another low degree polynomial. But for an honest prover, it's not hard to see that V(x) will be lower degree than C(x), since the roots of Z(x) line up perfectly with roots of C(x).				

The Prover evaluates V(x) over the $5, 5^4, \ldots, 5^{93}$, commits the values to a `validity Merkle tree`, and appends the root to the seal. 			

>The construction of these polynomials is the core conceptual thrust of RISC Zero's proof of trace validity. All of the information necessary to confirm the validity of the original Execution trace can be described in the following assertions about these polynomials: 											

>(i) V(x) = C(x) / Z(x) for all x		

>(ii) The degree of the `validity polynomial` and each `trace polynomials` are less than or equal to 7.	

>The FRI protocol is the technique we use for proving (ii). Those details are omitted from this simplified example. 								

>In the original STARK protocol, the Verifier tests (i) at a number of test points; the soundness of the protocol depends on the number of tests. The DEEP-ALI technique allows us to achieve a high degree of soundness with a single test. The details of DEEP are described in the following lesson.	
										
## Lesson 9: The DEEP Technique

Here, we use the `trace polynomials` and the `validity polynomial`(s) to construct the `DEEP polynomials`. 

>The `DEEP polynomials` allow the Verifier to test $V(x) = C(x) / Z(x)$ outside the original Merkle tree commitments, which substantially improves the robustness of the Verifier's test. 	

Without the DEEP technique, the Prover would assert that the trace polynomials $d_1, d_2, d_3, c_1, c_2, c_3,$ and the validity polynomial $V$ were all low degree polynomials. 																			
With the DEEP technique, the Prover argues instead that $d'_1, d'_2, d'_3, c'_1, c'_2, c'_3,$ and $V'$ are low degree polynomials.

With commitments of the `trace polynomials` and the `validity polynomial` in place, the Verifier uses the entropy of the seal to randomly choose a `DEEP test point`, $z$. We use $z=93$ in this example. 

The Verifier would like to be able to compute the `mixed constraint polynomial`, $C(93)$. The Prover sends $V(93)$ and the `necessary evaluations` of the `trace polynomials` to allow the Verifer to compute $C(93)$. 	

In this example, the `necessary evaluations` are $d_1(93), d_2(93), d_3(93), c_1(93), c_2(93), c_3(93), d_2(93\cdot5^{-12}), d_3(93\cdot 5^{-12})$, shown in salmon. Note that $5^{-12}$ is a pointer backwards 1 computational step; by pointing forward and backward, the `taps` allow for checking the rules that span multiple clock-cycles.	

![Lesson 9: The DEEP Technique](assets/fibonacci-09a.png)

> These 8 points, together with the publicly known rule-checking functions, allow the Verifier to manually compute $C(93)$ and therefore $V(93)$.
																	
The Prover also constructs the `DEEP polynomials`, interpolates each one, and sends the coefficients of each DEEP polynomial to the Verifier. The `DEEP polynomials` are defined as follows:	

$d'_1(x) = \frac{d_1(x) - d_1(93)}{x - 93}$	
	
$d'_2(x) = \frac{d_2(x) - \overline{d_2}(x)}{(x-93)(x-6)}$ where $\overline{d_2}(x)$ is constructed by interpolating $(6, d_2(6))$ and $(93, d_2(93))$.

$d'_3(x) = \frac{d_3(x) - \overline{d_3}(x)}{(x-93)(x-6)}$ where $\overline{d_3}(x)$ is constructed by interpolating $(6, d_3(6))$ and $(93, d_3(93))$


$c'_1(x) = \frac{c_1(x) - c_1(93)}{x - 93}$		

$c'_2(x) = \frac{c_2(x) - c_2(93)}{x - 93}$

$c'_3(x) = \frac{c_3(x) - c_3(93)}{x - 93}$		

$V'(x)  = \frac{V(x) - V(93)}{x - 93}$ where the Prover computes V(93) by running `iNTT(ValidityColumn)` and then evaluating the resulting `validity polynomial` at $z=93$.

## Lesson 10: Mixing for FRI

After using the `DEEP polynomials` to check the relation between the Trace Polynomial, the `validity polynomial`, and the `zeros polynomial` at $z=93$, the only thing left for the Prover to do is to show that the `DEEP polynomials` are low-degree. 	

The FRI protocol provides a mechanism for the Verifier to confirm the low-degree-ness of polynomials, with very little computation required of the Verifier. In order to reduce this assertion of low-degree-ness to a single application of FRI, the Prover mixes the `DEEP polynomials` into a single FRI polynomial, using the DEEP Mixing parameter, $\alpha_2$.					

Letting $c'_1, c'_2, c'_3, d'_1, d'_2, d'_3$, and $V'$ denote the `DEEP polynomials`, we mix the `DEEP polynomials` to construct the FRI polynomial, $f_0(x) = \alpha_2 ^0c'_1(x) + \alpha_2 ^1 c'_2(x) + ... + \alpha_2 ^6V'(x)$		

				
![Lesson 11: Mixing for FRI](assets/fibonacci-10.png)

To complete the argument, the Prover constructs a FRI proof that $f_0(x)$ is a low degree polynomial. With this process, the Prover has constructed a zero-knowledge argument of computational integrity. We omit the details of FRI for brevity, but we can check our work by running an iNTT on the evaluations of $f_0$: 

>`iNTT([53,69,63,30,46,13,60,50,38,3,95,23,75,39,62,19,62,58,41,67,89,41,50,24,95,90,72,20,82,33,0,16],prime=97)`

returns

>`[19, 56, 34, 48, 43, 37, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]`

Writing this array as the coefficients of a polynomial, we see that the values in the FRI polynomial column *do*, in fact, correspond to the following low-degree polynomial: 

$f_0(x)=19+56x+34x^2+48x^3+43x^4+37x^5+10x^6$.

Whew! Congratulations and thank you for making it this far!

Got questions, feedback, or corrections? Find us on [Twitter](https://twitter.com/risczero) and [Discord](https://discord.gg/risczero).
